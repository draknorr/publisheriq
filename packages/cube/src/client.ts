/**
 * Cube.dev Client for PublisherIQ
 *
 * Provides typed access to Cube.dev REST API with JWT authentication.
 */

import jwt from 'jsonwebtoken';

// Types for Cube.dev queries
export interface CubeFilter {
  member: string;
  operator:
    | 'equals'
    | 'notEquals'
    | 'contains'
    | 'notContains'
    | 'gt'
    | 'gte'
    | 'lt'
    | 'lte'
    | 'set'
    | 'notSet'
    | 'inDateRange'
    | 'notInDateRange'
    | 'beforeDate'
    | 'afterDate';
  values?: (string | number | boolean)[];
}

export interface CubeTimeDimension {
  dimension: string;
  granularity?: 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';
  dateRange?: string | [string, string];
}

export interface CubeQuery {
  measures?: string[];
  dimensions?: string[];
  filters?: CubeFilter[];
  timeDimensions?: CubeTimeDimension[];
  segments?: string[];
  order?: Record<string, 'asc' | 'desc'>;
  limit?: number;
  offset?: number;
}

export interface CubeResultSet<T = Record<string, unknown>> {
  data: T[];
  annotation: {
    measures: Record<string, { title: string; shortTitle: string; type: string }>;
    dimensions: Record<string, { title: string; shortTitle: string; type: string }>;
    segments: Record<string, { title: string; shortTitle: string }>;
    timeDimensions: Record<string, { title: string; shortTitle: string; type: string }>;
  };
}

export interface CubeClientConfig {
  apiUrl: string;
  apiSecret: string;
  tokenExpiry?: number; // seconds, default 3600
}

/**
 * Generate a JWT token for Cube.dev API authentication
 */
export function generateCubeToken(apiSecret: string, expirySeconds = 3600): string {
  const now = Math.floor(Date.now() / 1000);

  return jwt.sign(
    {
      iss: 'publisheriq-admin',
      iat: now,
      exp: now + expirySeconds,
    },
    apiSecret,
    { algorithm: 'HS256' }
  );
}

/**
 * Cube.dev API Client
 */
export class CubeClient {
  private apiUrl: string;
  private apiSecret: string;
  private tokenExpiry: number;
  private cachedToken: string | null = null;
  private tokenExpiresAt = 0;

  constructor(config: CubeClientConfig) {
    this.apiUrl = config.apiUrl.replace(/\/$/, ''); // Remove trailing slash
    this.apiSecret = config.apiSecret;
    this.tokenExpiry = config.tokenExpiry ?? 3600;
  }

  /**
   * Get or refresh the JWT token
   */
  private getToken(): string {
    const now = Math.floor(Date.now() / 1000);

    // Refresh token 60 seconds before expiry
    if (!this.cachedToken || now >= this.tokenExpiresAt - 60) {
      this.cachedToken = generateCubeToken(this.apiSecret, this.tokenExpiry);
      this.tokenExpiresAt = now + this.tokenExpiry;
    }

    return this.cachedToken;
  }

  /**
   * Execute a Cube.dev query
   */
  async load<T = Record<string, unknown>>(query: CubeQuery): Promise<CubeResultSet<T>> {
    const token = this.getToken();

    const response = await fetch(`${this.apiUrl}/cubejs-api/v1/load`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ query }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Cube.dev query failed: ${response.status} ${error}`);
    }

    return response.json();
  }

  /**
   * Get SQL generated by Cube.dev (for debugging)
   */
  async sql(query: CubeQuery): Promise<{ sql: { sql: string[]; params: unknown[] } }> {
    const token = this.getToken();

    const response = await fetch(`${this.apiUrl}/cubejs-api/v1/sql`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ query }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Cube.dev SQL request failed: ${response.status} ${error}`);
    }

    return response.json();
  }

  /**
   * Get meta information about available cubes
   */
  async meta(): Promise<{
    cubes: Array<{
      name: string;
      title: string;
      measures: Array<{ name: string; title: string; type: string }>;
      dimensions: Array<{ name: string; title: string; type: string }>;
      segments: Array<{ name: string; title: string }>;
    }>;
  }> {
    const token = this.getToken();

    const response = await fetch(`${this.apiUrl}/cubejs-api/v1/meta`, {
      method: 'GET',
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Cube.dev meta request failed: ${response.status} ${error}`);
    }

    return response.json();
  }

  /**
   * Check if Cube.dev is healthy
   */
  async health(): Promise<boolean> {
    try {
      const response = await fetch(`${this.apiUrl}/readyz`);
      return response.ok;
    } catch {
      return false;
    }
  }
}

/**
 * Create a Cube.dev client from environment variables
 */
export function createCubeClient(): CubeClient {
  const apiUrl = process.env.CUBE_API_URL;
  const apiSecret = process.env.CUBE_API_SECRET;

  if (!apiUrl || !apiSecret) {
    throw new Error('CUBE_API_URL and CUBE_API_SECRET environment variables are required');
  }

  return new CubeClient({ apiUrl, apiSecret });
}

// Re-export types
export type { CubeQuery, CubeFilter, CubeTimeDimension, CubeResultSet, CubeClientConfig };
